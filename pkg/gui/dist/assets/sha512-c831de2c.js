import{X as zt,y as mt,Y as wt,C as Vt,Z as te,D as Gt,$ as M,z as ee,a0 as ne,f as re,r as se,a1 as v}from"./index-26bde2f5.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jt=BigInt(0),xt=BigInt(1),ie=BigInt(2),pt=n=>n instanceof Uint8Array,oe=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function lt(n){if(!pt(n))throw new Error("Uint8Array expected");let e="";for(let t=0;t<n.length;t++)e+=oe[n[t]];return e}function Ft(n){const e=n.toString(16);return e.length&1?`0${e}`:e}function Ht(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}function ht(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const e=n.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const t=new Uint8Array(e/2);for(let r=0;r<t.length;r++){const s=r*2,o=n.slice(s,s+2),f=Number.parseInt(o,16);if(Number.isNaN(f)||f<0)throw new Error("Invalid byte sequence");t[r]=f}return t}function it(n){return Ht(lt(n))}function Lt(n){if(!pt(n))throw new Error("Uint8Array expected");return Ht(lt(Uint8Array.from(n).reverse()))}function dt(n,e){return ht(n.toString(16).padStart(e*2,"0"))}function Nt(n,e){return dt(n,e).reverse()}function ce(n){return ht(Ft(n))}function D(n,e,t){let r;if(typeof e=="string")try{r=ht(e)}catch(o){throw new Error(`${n} must be valid hex string, got "${e}". Cause: ${o}`)}else if(pt(e))r=Uint8Array.from(e);else throw new Error(`${n} must be hex string or Uint8Array`);const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(`${n} expected ${t} bytes, got ${s}`);return r}function bt(...n){const e=new Uint8Array(n.reduce((r,s)=>r+s.length,0));let t=0;return n.forEach(r=>{if(!pt(r))throw new Error("Uint8Array expected");e.set(r,t),t+=r.length}),e}function fe(n,e){if(n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function ae(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function le(n){let e;for(e=0;n>jt;n>>=xt,e+=1);return e}function he(n,e){return n>>BigInt(e)&xt}const de=(n,e,t)=>n|(t?xt:jt)<<BigInt(e),qt=n=>(ie<<BigInt(n-1))-xt,Et=n=>new Uint8Array(n),Tt=n=>Uint8Array.from(n);function Dt(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=Et(n),s=Et(n),o=0;const f=()=>{r.fill(1),s.fill(0),o=0},c=(...l)=>t(s,r,...l),i=(l=Et())=>{s=c(Tt([0]),l),r=c(),l.length!==0&&(s=c(Tt([1]),l),r=c())},a=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const m=[];for(;l<e;){r=c();const I=r.slice();m.push(I),l+=r.length}return bt(...m)};return(l,m)=>{f(),i(l);let I;for(;!(I=m(a()));)i();return f(),I}}const ue={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||n instanceof Uint8Array,isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function gt(n,e,t={}){const r=(s,o,f)=>{const c=ue[o];if(typeof c!="function")throw new Error(`Invalid validator "${o}", expected function`);const i=n[s];if(!(f&&i===void 0)&&!c(i,n))throw new Error(`Invalid param ${String(s)}=${i} (${typeof i}), expected ${o}`)};for(const[s,o]of Object.entries(e))r(s,o,!1);for(const[s,o]of Object.entries(t))r(s,o,!0);return n}const be=Object.freeze(Object.defineProperty({__proto__:null,bitGet:he,bitLen:le,bitMask:qt,bitSet:de,bytesToHex:lt,bytesToNumberBE:it,bytesToNumberLE:Lt,concatBytes:bt,createHmacDrbg:Dt,ensureBytes:D,equalBytes:fe,hexToBytes:ht,hexToNumber:Ht,numberToBytesBE:dt,numberToBytesLE:Nt,numberToHexUnpadded:Ft,numberToVarBytesBE:ce,utf8ToBytes:ae,validateObject:gt},Symbol.toStringTag,{value:"Module"}));function ge(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),o=BigInt(4294967295),f=Number(t>>s&o),c=Number(t&o),i=r?4:0,a=r?0:4;n.setUint32(e+i,f,r),n.setUint32(e+a,c,r)}class Yt extends zt{constructor(e,t,r,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=mt(this.buffer)}update(e){wt(this);const{view:t,buffer:r,blockLen:s}=this;e=Vt(e);const o=e.length;for(let f=0;f<o;){const c=Math.min(s-this.pos,o-f);if(c===s){const i=mt(e);for(;s<=o-f;f+=s)this.process(i,f);continue}r.set(e.subarray(f,f+c),this.pos),this.pos+=c,f+=c,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){wt(this),te(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:o}=this;let{pos:f}=this;t[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>s-f&&(this.process(r,0),f=0);for(let l=f;l<s;l++)t[l]=0;ge(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=mt(e),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=i/4,w=this.get();if(a>w.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)c.setUint32(4*l,w[l],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:o,destroyed:f,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=f,s%t&&e.buffer.set(r),e}}const we=(n,e,t)=>n&e^~n&t,xe=(n,e,t)=>n&e^n&t^e&t,pe=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Q=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),J=new Uint32Array(64);class ye extends Yt{constructor(){super(64,32,8,!1),this.A=Q[0]|0,this.B=Q[1]|0,this.C=Q[2]|0,this.D=Q[3]|0,this.E=Q[4]|0,this.F=Q[5]|0,this.G=Q[6]|0,this.H=Q[7]|0}get(){const{A:e,B:t,C:r,D:s,E:o,F:f,G:c,H:i}=this;return[e,t,r,s,o,f,c,i]}set(e,t,r,s,o,f,c,i){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=f|0,this.G=c|0,this.H=i|0}process(e,t){for(let l=0;l<16;l++,t+=4)J[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){const m=J[l-15],I=J[l-2],p=M(m,7)^M(m,18)^m>>>3,h=M(I,17)^M(I,19)^I>>>10;J[l]=h+J[l-7]+p+J[l-16]|0}let{A:r,B:s,C:o,D:f,E:c,F:i,G:a,H:w}=this;for(let l=0;l<64;l++){const m=M(c,6)^M(c,11)^M(c,25),I=w+m+we(c,i,a)+pe[l]+J[l]|0,h=(M(r,2)^M(r,13)^M(r,22))+xe(r,s,o)|0;w=a,a=i,i=c,c=f+I|0,f=o,o=s,s=r,r=I+h|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,f=f+this.D|0,c=c+this.E|0,i=i+this.F|0,a=a+this.G|0,w=w+this.H|0,this.set(r,s,o,f,c,i,a,w)}roundClean(){J.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const me=Gt(()=>new ye);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Z=BigInt(0),C=BigInt(1),rt=BigInt(2),Ee=BigInt(3),St=BigInt(4),_t=BigInt(5),$t=BigInt(8);BigInt(9);BigInt(16);function k(n,e){const t=n%e;return t>=Z?t:e+t}function Be(n,e,t){if(t<=Z||e<Z)throw new Error("Expected power/modulo > 0");if(t===C)return Z;let r=C;for(;e>Z;)e&C&&(r=r*n%t),n=n*n%t,e>>=C;return r}function G(n,e,t){let r=n;for(;e-- >Z;)r*=r,r%=t;return r}function At(n,e){if(n===Z||e<=Z)throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);let t=k(n,e),r=e,s=Z,o=C;for(;t!==Z;){const c=r/t,i=r%t,a=s-o*c;r=t,t=i,s=o,o=a}if(r!==C)throw new Error("invert: does not exist");return k(s,e)}function Se(n){const e=(n-C)/rt;let t,r,s;for(t=n-C,r=0;t%rt===Z;t/=rt,r++);for(s=rt;s<n&&Be(s,e,n)!==n-C;s++);if(r===1){const f=(n+C)/St;return function(i,a){const w=i.pow(a,f);if(!i.eql(i.sqr(w),a))throw new Error("Cannot find square root");return w}}const o=(t+C)/rt;return function(c,i){if(c.pow(i,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,w=c.pow(c.mul(c.ONE,s),t),l=c.pow(i,o),m=c.pow(i,t);for(;!c.eql(m,c.ONE);){if(c.eql(m,c.ZERO))return c.ZERO;let I=1;for(let h=c.sqr(m);I<a&&!c.eql(h,c.ONE);I++)h=c.sqr(h);const p=c.pow(w,C<<BigInt(a-I-1));w=c.sqr(p),l=c.mul(l,p),m=c.mul(m,w),a=I}return l}}function Ae(n){if(n%St===Ee){const e=(n+C)/St;return function(r,s){const o=r.pow(s,e);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(n%$t===_t){const e=(n-_t)/$t;return function(r,s){const o=r.mul(s,rt),f=r.pow(o,e),c=r.mul(s,f),i=r.mul(r.mul(c,rt),f),a=r.mul(c,r.sub(i,r.ONE));if(!r.eql(r.sqr(a),s))throw new Error("Cannot find square root");return a}}return Se(n)}const Ke=(n,e)=>(k(n,e)&C)===C,Ie=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ve(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Ie.reduce((r,s)=>(r[s]="function",r),e);return gt(n,t)}function He(n,e,t){if(t<Z)throw new Error("Expected power > 0");if(t===Z)return n.ONE;if(t===C)return e;let r=n.ONE,s=e;for(;t>Z;)t&C&&(r=n.mul(r,s)),s=n.sqr(s),t>>=C;return r}function Le(n,e){const t=new Array(e.length),r=e.reduce((o,f,c)=>n.is0(f)?o:(t[c]=o,n.mul(o,f)),n.ONE),s=n.inv(r);return e.reduceRight((o,f,c)=>n.is0(f)?o:(t[c]=n.mul(o,t[c]),n.mul(o,f)),s),t}function Mt(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Ne(n,e,t=!1,r={}){if(n<=Z)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:s,nByteLength:o}=Mt(n,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=Ae(n),c=Object.freeze({ORDER:n,BITS:s,BYTES:o,MASK:qt(s),ZERO:Z,ONE:C,create:i=>k(i,n),isValid:i=>{if(typeof i!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof i}`);return Z<=i&&i<n},is0:i=>i===Z,isOdd:i=>(i&C)===C,neg:i=>k(-i,n),eql:(i,a)=>i===a,sqr:i=>k(i*i,n),add:(i,a)=>k(i+a,n),sub:(i,a)=>k(i-a,n),mul:(i,a)=>k(i*a,n),pow:(i,a)=>He(c,i,a),div:(i,a)=>k(i*At(a,n),n),sqrN:i=>i*i,addN:(i,a)=>i+a,subN:(i,a)=>i-a,mulN:(i,a)=>i*a,inv:i=>At(i,n),sqrt:r.sqrt||(i=>f(c,i)),invertBatch:i=>Le(c,i),cmov:(i,a,w)=>w?a:i,toBytes:i=>t?Nt(i,o):dt(i,o),fromBytes:i=>{if(i.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${i.length}`);return t?Lt(i):it(i)}});return Object.freeze(c)}function We(n,e){if(!n.isOdd)throw new Error("Field doesn't have isOdd");const t=n.sqrt(e);return n.isOdd(t)?n.neg(t):t}function Kt(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function Wt(n){const e=Kt(n);return e+Math.ceil(e/2)}function qe(n,e,t=!1){const r=n.length,s=Kt(e),o=Wt(e);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const f=t?it(n):Lt(n),c=k(f,e-C)+C;return t?Nt(c,s):dt(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Oe=BigInt(0),Bt=BigInt(1);function Ue(n,e){const t=(s,o)=>{const f=o.negate();return s?f:o},r=s=>{const o=Math.ceil(e/s)+1,f=2**(s-1);return{windows:o,windowSize:f}};return{constTimeNegate:t,unsafeLadder(s,o){let f=n.ZERO,c=s;for(;o>Oe;)o&Bt&&(f=f.add(c)),c=c.double(),o>>=Bt;return f},precomputeWindow(s,o){const{windows:f,windowSize:c}=r(o),i=[];let a=s,w=a;for(let l=0;l<f;l++){w=a,i.push(w);for(let m=1;m<c;m++)w=w.add(a),i.push(w);a=w.double()}return i},wNAF(s,o,f){const{windows:c,windowSize:i}=r(s);let a=n.ZERO,w=n.BASE;const l=BigInt(2**s-1),m=2**s,I=BigInt(s);for(let p=0;p<c;p++){const h=p*i;let u=Number(f&l);f>>=I,u>i&&(u-=m,f+=Bt);const b=h,E=h+Math.abs(u)-1,g=p%2!==0,H=u<0;u===0?w=w.add(t(g,o[b])):a=a.add(t(H,o[E]))}return{p:a,f:w}},wNAFCached(s,o,f,c){const i=s._WINDOW_SIZE||1;let a=o.get(s);return a||(a=this.precomputeWindow(s,i),i!==1&&o.set(s,c(a))),this.wNAF(i,a,f)}}}function Pt(n){return ve(n.Fp),gt(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Mt(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ce(n){const e=Pt(n);gt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:s}=e;if(t){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Te,hexToBytes:_e}=be,st={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(n){const{Err:e}=st;if(n.length<2||n[0]!==2)throw new e("Invalid signature integer tag");const t=n[1],r=n.subarray(2,t+2);if(!t||r.length!==t)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Te(r),l:n.subarray(t+2)}},toSig(n){const{Err:e}=st,t=typeof n=="string"?_e(n):n;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let r=t.length;if(r<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:s,l:o}=st._parseInt(t.subarray(2)),{d:f,l:c}=st._parseInt(o);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:f}},hexFromSig(n){const e=a=>Number.parseInt(a[0],16)&8?"00"+a:a,t=a=>{const w=a.toString(16);return w.length&1?`0${w}`:w},r=e(t(n.s)),s=e(t(n.r)),o=r.length/2,f=s.length/2,c=t(o),i=t(f);return`30${t(f+o+4)}02${i}${s}02${c}${r}`}},K=BigInt(0),j=BigInt(1);BigInt(2);const Zt=BigInt(3);BigInt(4);function $e(n){const e=Ce(n),{Fp:t}=e,r=e.toBytes||((p,h,u)=>{const b=h.toAffine();return bt(Uint8Array.from([4]),t.toBytes(b.x),t.toBytes(b.y))}),s=e.fromBytes||(p=>{const h=p.subarray(1),u=t.fromBytes(h.subarray(0,t.BYTES)),b=t.fromBytes(h.subarray(t.BYTES,2*t.BYTES));return{x:u,y:b}});function o(p){const{a:h,b:u}=e,b=t.sqr(p),E=t.mul(b,p);return t.add(t.add(E,t.mul(p,h)),u)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function f(p){return typeof p=="bigint"&&K<p&&p<e.n}function c(p){if(!f(p))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function i(p){const{allowedPrivateKeyLengths:h,nByteLength:u,wrapPrivateKey:b,n:E}=e;if(h&&typeof p!="bigint"){if(p instanceof Uint8Array&&(p=lt(p)),typeof p!="string"||!h.includes(p.length))throw new Error("Invalid key");p=p.padStart(u*2,"0")}let g;try{g=typeof p=="bigint"?p:it(D("private key",p,u))}catch{throw new Error(`private key must be ${u} bytes, hex or bigint, not ${typeof p}`)}return b&&(g=k(g,E)),c(g),g}const a=new Map;function w(p){if(!(p instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(h,u,b){if(this.px=h,this.py=u,this.pz=b,h==null||!t.isValid(h))throw new Error("x required");if(u==null||!t.isValid(u))throw new Error("y required");if(b==null||!t.isValid(b))throw new Error("z required")}static fromAffine(h){const{x:u,y:b}=h||{};if(!h||!t.isValid(u)||!t.isValid(b))throw new Error("invalid affine point");if(h instanceof l)throw new Error("projective point not allowed");const E=g=>t.eql(g,t.ZERO);return E(u)&&E(b)?l.ZERO:new l(u,b,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const u=t.invertBatch(h.map(b=>b.pz));return h.map((b,E)=>b.toAffine(u[E])).map(l.fromAffine)}static fromHex(h){const u=l.fromAffine(s(D("pointHex",h)));return u.assertValidity(),u}static fromPrivateKey(h){return l.BASE.multiply(i(h))}_setWindowSize(h){this._WINDOW_SIZE=h,a.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:h,y:u}=this.toAffine();if(!t.isValid(h)||!t.isValid(u))throw new Error("bad point: x or y not FE");const b=t.sqr(u),E=o(h);if(!t.eql(b,E))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:h}=this.toAffine();if(t.isOdd)return!t.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){w(h);const{px:u,py:b,pz:E}=this,{px:g,py:H,pz:A}=h,y=t.eql(t.mul(u,A),t.mul(g,E)),S=t.eql(t.mul(b,A),t.mul(H,E));return y&&S}negate(){return new l(this.px,t.neg(this.py),this.pz)}double(){const{a:h,b:u}=e,b=t.mul(u,Zt),{px:E,py:g,pz:H}=this;let A=t.ZERO,y=t.ZERO,S=t.ZERO,B=t.mul(E,E),T=t.mul(g,g),q=t.mul(H,H),N=t.mul(E,g);return N=t.add(N,N),S=t.mul(E,H),S=t.add(S,S),A=t.mul(h,S),y=t.mul(b,q),y=t.add(A,y),A=t.sub(T,y),y=t.add(T,y),y=t.mul(A,y),A=t.mul(N,A),S=t.mul(b,S),q=t.mul(h,q),N=t.sub(B,q),N=t.mul(h,N),N=t.add(N,S),S=t.add(B,B),B=t.add(S,B),B=t.add(B,q),B=t.mul(B,N),y=t.add(y,B),q=t.mul(g,H),q=t.add(q,q),B=t.mul(q,N),A=t.sub(A,B),S=t.mul(q,T),S=t.add(S,S),S=t.add(S,S),new l(A,y,S)}add(h){w(h);const{px:u,py:b,pz:E}=this,{px:g,py:H,pz:A}=h;let y=t.ZERO,S=t.ZERO,B=t.ZERO;const T=e.a,q=t.mul(e.b,Zt);let N=t.mul(u,g),_=t.mul(b,H),R=t.mul(E,A),Y=t.add(u,b),d=t.add(g,H);Y=t.mul(Y,d),d=t.add(N,_),Y=t.sub(Y,d),d=t.add(u,E);let x=t.add(g,A);return d=t.mul(d,x),x=t.add(N,R),d=t.sub(d,x),x=t.add(b,E),y=t.add(H,A),x=t.mul(x,y),y=t.add(_,R),x=t.sub(x,y),B=t.mul(T,d),y=t.mul(q,R),B=t.add(y,B),y=t.sub(_,B),B=t.add(_,B),S=t.mul(y,B),_=t.add(N,N),_=t.add(_,N),R=t.mul(T,R),d=t.mul(q,d),_=t.add(_,R),R=t.sub(N,R),R=t.mul(T,R),d=t.add(d,R),N=t.mul(_,d),S=t.add(S,N),N=t.mul(x,d),y=t.mul(Y,y),y=t.sub(y,N),N=t.mul(Y,_),B=t.mul(x,B),B=t.add(B,N),new l(y,S,B)}subtract(h){return this.add(h.negate())}is0(){return this.equals(l.ZERO)}wNAF(h){return I.wNAFCached(this,a,h,u=>{const b=t.invertBatch(u.map(E=>E.pz));return u.map((E,g)=>E.toAffine(b[g])).map(l.fromAffine)})}multiplyUnsafe(h){const u=l.ZERO;if(h===K)return u;if(c(h),h===j)return this;const{endo:b}=e;if(!b)return I.unsafeLadder(this,h);let{k1neg:E,k1:g,k2neg:H,k2:A}=b.splitScalar(h),y=u,S=u,B=this;for(;g>K||A>K;)g&j&&(y=y.add(B)),A&j&&(S=S.add(B)),B=B.double(),g>>=j,A>>=j;return E&&(y=y.negate()),H&&(S=S.negate()),S=new l(t.mul(S.px,b.beta),S.py,S.pz),y.add(S)}multiply(h){c(h);let u=h,b,E;const{endo:g}=e;if(g){const{k1neg:H,k1:A,k2neg:y,k2:S}=g.splitScalar(u);let{p:B,f:T}=this.wNAF(A),{p:q,f:N}=this.wNAF(S);B=I.constTimeNegate(H,B),q=I.constTimeNegate(y,q),q=new l(t.mul(q.px,g.beta),q.py,q.pz),b=B.add(q),E=T.add(N)}else{const{p:H,f:A}=this.wNAF(u);b=H,E=A}return l.normalizeZ([b,E])[0]}multiplyAndAddUnsafe(h,u,b){const E=l.BASE,g=(A,y)=>y===K||y===j||!A.equals(E)?A.multiplyUnsafe(y):A.multiply(y),H=g(this,u).add(g(h,b));return H.is0()?void 0:H}toAffine(h){const{px:u,py:b,pz:E}=this,g=this.is0();h==null&&(h=g?t.ONE:t.inv(E));const H=t.mul(u,h),A=t.mul(b,h),y=t.mul(E,h);if(g)return{x:t.ZERO,y:t.ZERO};if(!t.eql(y,t.ONE))throw new Error("invZ was invalid");return{x:H,y:A}}isTorsionFree(){const{h,isTorsionFree:u}=e;if(h===j)return!0;if(u)return u(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:u}=e;return h===j?this:u?u(l,this):this.multiplyUnsafe(e.h)}toRawBytes(h=!0){return this.assertValidity(),r(l,this,h)}toHex(h=!0){return lt(this.toRawBytes(h))}}l.BASE=new l(e.Gx,e.Gy,t.ONE),l.ZERO=new l(t.ZERO,t.ONE,t.ZERO);const m=e.nBitLength,I=Ue(l,e.endo?Math.ceil(m/2):m);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:i,weierstrassEquation:o,isWithinCurveOrder:f}}function Ze(n){const e=Pt(n);return gt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Re(n){const e=Ze(n),{Fp:t,n:r}=e,s=t.BYTES+1,o=2*t.BYTES+1;function f(d){return K<d&&d<t.ORDER}function c(d){return k(d,r)}function i(d){return At(d,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:w,weierstrassEquation:l,isWithinCurveOrder:m}=$e({...e,toBytes(d,x,L){const U=x.toAffine(),O=t.toBytes(U.x),$=bt;return L?$(Uint8Array.from([x.hasEvenY()?2:3]),O):$(Uint8Array.from([4]),O,t.toBytes(U.y))},fromBytes(d){const x=d.length,L=d[0],U=d.subarray(1);if(x===s&&(L===2||L===3)){const O=it(U);if(!f(O))throw new Error("Point is not on curve");const $=l(O);let z=t.sqrt($);const V=(z&j)===j;return(L&1)===1!==V&&(z=t.neg(z)),{x:O,y:z}}else if(x===o&&L===4){const O=t.fromBytes(U.subarray(0,t.BYTES)),$=t.fromBytes(U.subarray(t.BYTES,2*t.BYTES));return{x:O,y:$}}else throw new Error(`Point of length ${x} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),I=d=>lt(dt(d,e.nByteLength));function p(d){const x=r>>j;return d>x}function h(d){return p(d)?c(-d):d}const u=(d,x,L)=>it(d.slice(x,L));class b{constructor(x,L,U){this.r=x,this.s=L,this.recovery=U,this.assertValidity()}static fromCompact(x){const L=e.nByteLength;return x=D("compactSignature",x,L*2),new b(u(x,0,L),u(x,L,2*L))}static fromDER(x){const{r:L,s:U}=st.toSig(D("DER",x));return new b(L,U)}assertValidity(){if(!m(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!m(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(x){return new b(this.r,this.s,x)}recoverPublicKey(x){const{r:L,s:U,recovery:O}=this,$=S(D("msgHash",x));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const z=O===2||O===3?L+e.n:L;if(z>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const V=O&1?"03":"02",W=a.fromHex(V+I(z)),P=i(z),ot=c(-$*P),ut=c(U*P),X=a.BASE.multiplyAndAddUnsafe(W,ot,ut);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new b(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return st.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){return I(this.r)+I(this.s)}}const E={isValidPrivateKey(d){try{return w(d),!0}catch{return!1}},normPrivateKeyToScalar:w,randomPrivateKey:()=>{const d=Wt(e.n);return qe(e.randomBytes(d),e.n)},precompute(d=8,x=a.BASE){return x._setWindowSize(d),x.multiply(BigInt(3)),x}};function g(d,x=!0){return a.fromPrivateKey(d).toRawBytes(x)}function H(d){const x=d instanceof Uint8Array,L=typeof d=="string",U=(x||L)&&d.length;return x?U===s||U===o:L?U===2*s||U===2*o:d instanceof a}function A(d,x,L=!0){if(H(d))throw new Error("first arg must be private key");if(!H(x))throw new Error("second arg must be public key");return a.fromHex(x).multiply(w(d)).toRawBytes(L)}const y=e.bits2int||function(d){const x=it(d),L=d.length*8-e.nBitLength;return L>0?x>>BigInt(L):x},S=e.bits2int_modN||function(d){return c(y(d))},B=qt(e.nBitLength);function T(d){if(typeof d!="bigint")throw new Error("bigint expected");if(!(K<=d&&d<B))throw new Error(`bigint expected < 2^${e.nBitLength}`);return dt(d,e.nByteLength)}function q(d,x,L=N){if(["recovered","canonical"].some(nt=>nt in L))throw new Error("sign() legacy options not supported");const{hash:U,randomBytes:O}=e;let{lowS:$,prehash:z,extraEntropy:V}=L;$==null&&($=!0),d=D("msgHash",d),z&&(d=D("prehashed msgHash",U(d)));const W=S(d),P=w(x),ot=[T(P),T(W)];if(V!=null){const nt=V===!0?O(t.BYTES):V;ot.push(D("extraEntropy",nt))}const ut=bt(...ot),X=W;function yt(nt){const ct=y(nt);if(!m(ct))return;const Ot=i(ct),ft=a.BASE.multiply(ct).toAffine(),F=c(ft.x);if(F===K)return;const at=c(Ot*c(X+F*P));if(at===K)return;let Ut=(ft.x===F?0:2)|Number(ft.y&j),Ct=at;return $&&p(at)&&(Ct=h(at),Ut^=1),new b(F,Ct,Ut)}return{seed:ut,k2sig:yt}}const N={lowS:e.lowS,prehash:!1},_={lowS:e.lowS,prehash:!1};function R(d,x,L=N){const{seed:U,k2sig:O}=q(d,x,L),$=e;return Dt($.hash.outputLen,$.nByteLength,$.hmac)(U,O)}a.BASE._setWindowSize(8);function Y(d,x,L,U=_){var ft;const O=d;if(x=D("msgHash",x),L=D("publicKey",L),"strict"in U)throw new Error("options.strict was renamed to lowS");const{lowS:$,prehash:z}=U;let V,W;try{if(typeof O=="string"||O instanceof Uint8Array)try{V=b.fromDER(O)}catch(F){if(!(F instanceof st.Err))throw F;V=b.fromCompact(O)}else if(typeof O=="object"&&typeof O.r=="bigint"&&typeof O.s=="bigint"){const{r:F,s:at}=O;V=new b(F,at)}else throw new Error("PARSE");W=a.fromHex(L)}catch(F){if(F.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if($&&V.hasHighS())return!1;z&&(x=e.hash(x));const{r:P,s:ot}=V,ut=S(x),X=i(ot),yt=c(ut*X),nt=c(P*X),ct=(ft=a.BASE.multiplyAndAddUnsafe(W,yt,nt))==null?void 0:ft.toAffine();return ct?c(ct.x)===P:!1}return{CURVE:e,getPublicKey:g,getSharedSecret:A,sign:R,verify:Y,ProjectivePoint:a,Signature:b,utils:E}}class Xt extends zt{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,ee(e);const r=Vt(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let f=0;f<o.length;f++)o[f]^=54;this.iHash.update(o),this.oHash=e.create();for(let f=0;f<o.length;f++)o[f]^=106;this.oHash.update(o),o.fill(0)}update(e){return wt(this),this.iHash.update(e),this}digestInto(e){wt(this),ne(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:o,blockLen:f,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=f,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Qt=(n,e,t)=>new Xt(n,e).update(t).digest();Qt.create=(n,e)=>new Xt(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ke(n){return{hash:n,hmac:(e,...t)=>Qt(n,e,re(...t)),randomBytes:se}}function ze(n,e){const t=r=>Re({...n,...ke(r)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Jt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Rt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ve=BigInt(1),It=BigInt(2),kt=(n,e)=>(n+e/It)/e;function Ge(n){const e=Jt,t=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),f=BigInt(23),c=BigInt(44),i=BigInt(88),a=n*n*n%e,w=a*a*n%e,l=G(w,t,e)*w%e,m=G(l,t,e)*w%e,I=G(m,It,e)*a%e,p=G(I,s,e)*I%e,h=G(p,o,e)*p%e,u=G(h,c,e)*h%e,b=G(u,i,e)*u%e,E=G(b,c,e)*h%e,g=G(E,t,e)*w%e,H=G(g,f,e)*p%e,A=G(H,r,e)*a%e,y=G(A,It,e);if(!vt.eql(vt.sqr(y),n))throw new Error("Cannot find square root");return y}const vt=Ne(Jt,void 0,void 0,{sqrt:Ge}),je=ze({a:BigInt(0),b:BigInt(7),Fp:vt,n:Rt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=Rt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Ve*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,f=BigInt("0x100000000000000000000000000000000"),c=kt(o*n,e),i=kt(-r*n,e);let a=k(n-c*t-i*s,e),w=k(-c*r-i*o,e);const l=a>f,m=w>f;if(l&&(a=e-a),m&&(w=e-w),a>f||w>f)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:l,k1:a,k2neg:m,k2:w}}}},me);BigInt(0);je.ProjectivePoint;const[Fe,De]=(()=>v.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))))(),tt=new Uint32Array(80),et=new Uint32Array(80);class Ye extends Yt{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:o,Cl:f,Dh:c,Dl:i,Eh:a,El:w,Fh:l,Fl:m,Gh:I,Gl:p,Hh:h,Hl:u}=this;return[e,t,r,s,o,f,c,i,a,w,l,m,I,p,h,u]}set(e,t,r,s,o,f,c,i,a,w,l,m,I,p,h,u){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=f|0,this.Dh=c|0,this.Dl=i|0,this.Eh=a|0,this.El=w|0,this.Fh=l|0,this.Fl=m|0,this.Gh=I|0,this.Gl=p|0,this.Hh=h|0,this.Hl=u|0}process(e,t){for(let g=0;g<16;g++,t+=4)tt[g]=e.getUint32(t),et[g]=e.getUint32(t+=4);for(let g=16;g<80;g++){const H=tt[g-15]|0,A=et[g-15]|0,y=v.rotrSH(H,A,1)^v.rotrSH(H,A,8)^v.shrSH(H,A,7),S=v.rotrSL(H,A,1)^v.rotrSL(H,A,8)^v.shrSL(H,A,7),B=tt[g-2]|0,T=et[g-2]|0,q=v.rotrSH(B,T,19)^v.rotrBH(B,T,61)^v.shrSH(B,T,6),N=v.rotrSL(B,T,19)^v.rotrBL(B,T,61)^v.shrSL(B,T,6),_=v.add4L(S,N,et[g-7],et[g-16]),R=v.add4H(_,y,q,tt[g-7],tt[g-16]);tt[g]=R|0,et[g]=_|0}let{Ah:r,Al:s,Bh:o,Bl:f,Ch:c,Cl:i,Dh:a,Dl:w,Eh:l,El:m,Fh:I,Fl:p,Gh:h,Gl:u,Hh:b,Hl:E}=this;for(let g=0;g<80;g++){const H=v.rotrSH(l,m,14)^v.rotrSH(l,m,18)^v.rotrBH(l,m,41),A=v.rotrSL(l,m,14)^v.rotrSL(l,m,18)^v.rotrBL(l,m,41),y=l&I^~l&h,S=m&p^~m&u,B=v.add5L(E,A,S,De[g],et[g]),T=v.add5H(B,b,H,y,Fe[g],tt[g]),q=B|0,N=v.rotrSH(r,s,28)^v.rotrBH(r,s,34)^v.rotrBH(r,s,39),_=v.rotrSL(r,s,28)^v.rotrBL(r,s,34)^v.rotrBL(r,s,39),R=r&o^r&c^o&c,Y=s&f^s&i^f&i;b=h|0,E=u|0,h=I|0,u=p|0,I=l|0,p=m|0,{h:l,l:m}=v.add(a|0,w|0,T|0,q|0),a=c|0,w=i|0,c=o|0,i=f|0,o=r|0,f=s|0;const d=v.add3L(q,_,Y);r=v.add3H(d,T,N,R),s=d|0}({h:r,l:s}=v.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:f}=v.add(this.Bh|0,this.Bl|0,o|0,f|0),{h:c,l:i}=v.add(this.Ch|0,this.Cl|0,c|0,i|0),{h:a,l:w}=v.add(this.Dh|0,this.Dl|0,a|0,w|0),{h:l,l:m}=v.add(this.Eh|0,this.El|0,l|0,m|0),{h:I,l:p}=v.add(this.Fh|0,this.Fl|0,I|0,p|0),{h,l:u}=v.add(this.Gh|0,this.Gl|0,h|0,u|0),{h:b,l:E}=v.add(this.Hh|0,this.Hl|0,b|0,E|0),this.set(r,s,o,f,c,i,a,w,l,m,I,p,h,u,b,E)}roundClean(){tt.fill(0),et.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Xe=Gt(()=>new Ye);export{Ne as F,Yt as S,gt as a,Lt as b,lt as c,bt as d,D as e,We as f,je as g,me as h,Ke as i,Qt as j,k as m,Nt as n,G as p,Xe as s,Pt as v,Ue as w};
